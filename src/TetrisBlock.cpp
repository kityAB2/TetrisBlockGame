#include "TetrisBlock.h"
// TFT_eSPI tft = TFT_eSPI();  // Invoke library, pins defined in User_Setup.h
uint16_t BlockImage[8][12][12] = {
  {
    { 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000 }
  },
  { 
    { 0x24F5, 0x1C33, 0x1C53, 0x1C32, 0x1C53, 0x1C33, 0x1C32, 0x1C32, 0x1C53, 0x1C33, 0x1C12, 0x3BF6 },
    { 0x0C94, 0xAFFF, 0x977D, 0x977D, 0x9F7E, 0x9F9E, 0xA79E, 0xA79E, 0xA79E, 0x977D, 0xA79F, 0x2394 },
    { 0x0C93, 0xBFFF, 0x6F9D, 0x5F7E, 0x575D, 0x3F3D, 0x375D, 0x2F3D, 0x2F3C, 0xB7FF, 0x5EDC, 0x2B74 },
    { 0x0C93, 0xC7FF, 0x271D, 0x271C, 0x271C, 0x2F1C, 0x371C, 0x371C, 0x3F3D, 0xAFDF, 0x063A, 0x2B95 },
    { 0x1474, 0xBFFF, 0x3F3D, 0x2F3C, 0x2F1C, 0x2F1C, 0x2F1C, 0x2F1C, 0x479E, 0x1E5A, 0x165A, 0x2B95 },
    { 0x0C74, 0xB7FF, 0x4F5E, 0x271C, 0x271C, 0x2F1C, 0x2F1C, 0x2F1C, 0x26FB, 0x0E5B, 0x0E9B, 0x2B95 },
    { 0x1473, 0xB7FF, 0x5F7E, 0x26FC, 0x2F1C, 0x2F3C, 0x2F1C, 0x2F1C, 0x271C, 0x0E7B, 0x0E5A, 0x2B95 },
    { 0x1474, 0xB7FF, 0x779E, 0x1EFC, 0x2F1D, 0x2F1C, 0x2F1C, 0x2F1D, 0x271C, 0x0E7A, 0x165B, 0x23B5 },
    { 0x0C93, 0xB7FF, 0x87BF, 0x1EFC, 0x2F3D, 0x2F3D, 0x2F3D, 0x2F3D, 0x2F1C, 0x0E5A, 0x0E7B, 0x2B95 },
    { 0x0C94, 0xBFFF, 0xA7DF, 0x16DB, 0x169B, 0x16BB, 0x169A, 0x169A, 0x0E7A, 0x167A, 0x165A, 0x2B95 },
    { 0x14B4, 0xA7FF, 0x06BB, 0x16DC, 0x16FC, 0x16FC, 0x16FC, 0x16FC, 0x16FC, 0x16DC, 0x16BC, 0x2B96 },
    { 0x14D4, 0x0C12, 0x0C32, 0x0C32, 0x0C32, 0x0C32, 0x1433, 0x1433, 0x0C32, 0x0C33, 0x0C33, 0x2BD6 }
  },
  { 
    { 0xCCE1, 0xC462, 0xC481, 0xC462, 0xC461, 0xCC62, 0xC461, 0xC461, 0xC481, 0xC462, 0xBC61, 0x8B43 },
    { 0xD4C1, 0xFFB3, 0xF751, 0xF750, 0xFF71, 0xF771, 0xF772, 0xFF72, 0xFF72, 0xF771, 0xEED1, 0x9BC4 },
    { 0xD4C1, 0xFFF5, 0xFF2F, 0xF72F, 0xFF0E, 0xF6EE, 0xF6EC, 0xF6CD, 0xFECD, 0xFFF4, 0xDE27, 0x9BA4 },
    { 0xD4C1, 0xFFF6, 0xF6AC, 0xF6AC, 0xFEAC, 0xF6CC, 0xF6AC, 0xF6CC, 0xF6ED, 0xF792, 0xDD60, 0x9BC5 },
    { 0xD4C0, 0xFFF5, 0xF6CC, 0xF6AC, 0xF6AC, 0xF6AC, 0xF6AC, 0xFE8D, 0xF6EF, 0xE600, 0xD5A0, 0x9BC4 },
    { 0xD4C1, 0xFFF5, 0xF6ED, 0xF6AC, 0xF6AC, 0xF6AC, 0xF6AC, 0xF6AB, 0xEE68, 0xE600, 0xDDA0, 0x9BC4 },
    { 0xD4C1, 0xFFF4, 0xF70E, 0xF6AB, 0xF6AC, 0xF6AC, 0xF6CC, 0xFEAC, 0xEE68, 0xEE00, 0xDD80, 0x9BC4 },
    { 0xDCA1, 0xFFF4, 0xFF2F, 0xF6AB, 0xF6CC, 0xF6AC, 0xF6CC, 0xF6CB, 0xF668, 0xE600, 0xDDA0, 0x9BC4 },
    { 0xD4C1, 0xFFF5, 0xFF50, 0xF68C, 0xF6CD, 0xF6CD, 0xFECE, 0xF6CE, 0xF689, 0xE600, 0xDDA1, 0x9BC4 },
    { 0xD4C1, 0xFFD5, 0xFF92, 0xEE45, 0xEE65, 0xEE24, 0xEE23, 0xE621, 0xE601, 0xEE00, 0xDDA0, 0xA3A5 },
    { 0xD4E2, 0xFFD1, 0xE5E0, 0xF640, 0xEE60, 0xEE60, 0xEE60, 0xEE60, 0xEE60, 0xEE60, 0xDDE0, 0x9BE5 },
    { 0xE520, 0xD500, 0xD500, 0xD500, 0xD520, 0xD500, 0xD4E0, 0xD4E0, 0xD4E0, 0xDD20, 0xCCC0, 0x93A3 }
  },
  { 
    { 0x2138, 0x18F9, 0x18F9, 0x18F9, 0x18F9, 0x18F9, 0x18D9, 0x18F9, 0x18F9, 0x18F9, 0x1919, 0x31FA },
    { 0x0015, 0x7BFE, 0x739E, 0x739E, 0x739E, 0x73BE, 0x7BDE, 0x7BDE, 0x7BFF, 0x73BD, 0x841F, 0x299C },
    { 0x0016, 0x94BF, 0x6B5E, 0x635E, 0x5B1E, 0x52DD, 0x4A9D, 0x4A7D, 0x39FC, 0x7BDF, 0x9CDF, 0x191A },
    { 0x0016, 0x8C9F, 0x529D, 0x3A1C, 0x3A1C, 0x423D, 0x423D, 0x423D, 0x39FC, 0x8C7F, 0x20FA, 0x215C },
    { 0x0016, 0x8C7F, 0x5AFD, 0x3A1D, 0x423D, 0x423D, 0x423C, 0x421C, 0x423D, 0x4A7C, 0x18FB, 0x217C },
    { 0x0016, 0x8C7F, 0x6B5E, 0x39FC, 0x423D, 0x423D, 0x423D, 0x423D, 0x425E, 0x1099, 0x18FA, 0x195B },
    { 0x0016, 0x8C7F, 0x73BF, 0x39DC, 0x423C, 0x423C, 0x423D, 0x423D, 0x425D, 0x109A, 0x18FA, 0x215B },
    { 0x0016, 0x8C9F, 0x83FF, 0x31DC, 0x423D, 0x423D, 0x423C, 0x423D, 0x425D, 0x109B, 0x18FA, 0x193B },
    { 0x0016, 0x8C7F, 0x8C3F, 0x31DD, 0x423D, 0x425D, 0x425D, 0x425D, 0x4A9D, 0x10BA, 0x18FA, 0x195C },
    { 0x0016, 0x8C7F, 0x949F, 0x423C, 0x31BC, 0x31BC, 0x297B, 0x295B, 0x213B, 0x109B, 0x18FB, 0x193B },
    { 0x0015, 0xA55F, 0x295C, 0x1099, 0x18FA, 0x18FA, 0x18DB, 0x18DB, 0x18FB, 0x18FB, 0x211A, 0x217B },
    { 0x0018, 0x085A, 0x001A, 0x003B, 0x003B, 0x003B, 0x003B, 0x003B, 0x003B, 0x003B, 0x003B, 0x111C }
  },
  { 
    { 0x88C0, 0x8020, 0x8020, 0x8020, 0x8020, 0x8020, 0x8020, 0x7820, 0x8020, 0x8020, 0x8020, 0x8820 },
    { 0x8000, 0xF3CF, 0xEBAE, 0xEB8E, 0xEBAE, 0xEBCF, 0xEBEF, 0xF3EF, 0xEBCE, 0xEBCE, 0xF3D0, 0x98E4 },
    { 0x8800, 0xEB6E, 0xDA49, 0xD1C7, 0xD1C6, 0xD186, 0xD186, 0xD166, 0xD125, 0xDAAA, 0xEB8E, 0x8800 },
    { 0x8000, 0xEB6E, 0xD9E7, 0xD185, 0xD986, 0xD186, 0xD186, 0xD165, 0xD125, 0xE34C, 0xA882, 0x9021 },
    { 0x8000, 0xEB6E, 0xDA48, 0xD145, 0xD165, 0xD186, 0xD186, 0xD986, 0xD986, 0xC186, 0xA882, 0x9020 },
    { 0x8000, 0xE36D, 0xDA89, 0xD145, 0xD186, 0xD165, 0xD986, 0xD965, 0xD9A6, 0xA861, 0xA882, 0x9021 },
    { 0x8000, 0xE36E, 0xDAEB, 0xD125, 0xD185, 0xD186, 0xD165, 0xD965, 0xD9C7, 0xA861, 0xB0A2, 0x9000 },
    { 0x8000, 0xE36D, 0xDB2C, 0xD924, 0xC9A6, 0xD185, 0xD185, 0xD985, 0xD9C6, 0xA861, 0xB0A2, 0x9000 },
    { 0x8000, 0xEB6D, 0xDB4D, 0xD124, 0xD986, 0xD986, 0xD186, 0xD986, 0xD9C7, 0xA882, 0xB082, 0x9020 },
    { 0x8000, 0xE36D, 0xE3AE, 0xC985, 0xC124, 0xB903, 0xB8E3, 0xB8C3, 0xB0C3, 0xA861, 0xA0A1, 0x9021 },
    { 0x8000, 0xFC50, 0xB8C3, 0xA841, 0xB082, 0xB082, 0xB082, 0xB0A2, 0xB082, 0xB082, 0xB0A2, 0x9022 },
    { 0x9060, 0x9061, 0x9040, 0x9060, 0x9060, 0x9060, 0x9040, 0x9060, 0x9040, 0x9060, 0x9040, 0x8800 }
  },
  { 
    { 0xBA63, 0xB223, 0xB222, 0xB223, 0xB222, 0xB222, 0xB222, 0xB222, 0xB222, 0xB222, 0xB223, 0xC1E3 },
    { 0xC344, 0xFE53, 0xFE12, 0xFE11, 0xFE31, 0xFE52, 0xFE53, 0xFE53, 0xFE52, 0xFE11, 0xFE75, 0xC286 },
    { 0xC304, 0xFDD0, 0xF427, 0xFC07, 0xFC06, 0xF3E6, 0xF3C5, 0xF3C4, 0xF383, 0xFD4F, 0xFD6F, 0xD222 },
    { 0xC304, 0xFDD1, 0xF3C4, 0xF405, 0xF3E5, 0xFBE5, 0xF3E5, 0xF3E5, 0xF383, 0xFDD1, 0xE2C1, 0xD242 },
    { 0xC304, 0xFDF2, 0xFBE6, 0xF3E5, 0xF3E4, 0xF3E4, 0xF3E4, 0xF3E4, 0xFBC5, 0xEBC7, 0xEAE1, 0xD242 },
    { 0xC304, 0xFDB1, 0xF406, 0xF3E5, 0xF3E4, 0xF3E4, 0xF3E4, 0xF3E4, 0xF3E5, 0xE2A0, 0xEAE1, 0xD242 },
    { 0xC304, 0xFDB1, 0xFC28, 0xF3E4, 0xF3E4, 0xF3E4, 0xF3E4, 0xF3E4, 0xFC05, 0xE2C0, 0xEAE1, 0xD242 },
    { 0xC304, 0xFD90, 0xF469, 0xFBC4, 0xF3E5, 0xF3E4, 0xF3E4, 0xF3E4, 0xF3E6, 0xE2C0, 0xE2C1, 0xD242 },
    { 0xC305, 0xFD8F, 0xFCCA, 0xF3A3, 0xF3C4, 0xFBE5, 0xF3E5, 0xFBE5, 0xFC06, 0xE2C0, 0xEAE1, 0xD242 },
    { 0xC324, 0xFD90, 0xFD4F, 0xF363, 0xF3A4, 0xF3A4, 0xEB63, 0xEB63, 0xEB43, 0xEAC0, 0xEAE1, 0xD242 },
    { 0xC324, 0xFE13, 0xEAC1, 0xEAE0, 0xEAE0, 0xEAE0, 0xEAE0, 0xEAE0, 0xEB02, 0xEAE0, 0xF301, 0xD242 },
    { 0xCB03, 0xCAA0, 0xCAA0, 0xCAA0, 0xCAA1, 0xCAA0, 0xD2A0, 0xCAA0, 0xD280, 0xCAA0, 0xCA81, 0xB227 }
  },
  { 
    { 0x05C5, 0x04A5, 0x04E5, 0x04C5, 0x04C5, 0x04C5, 0x04C5, 0x04C5, 0x04E6, 0x04C5, 0x04E6, 0x0565 },
    { 0x0505, 0x2608, 0x46CB, 0x46CB, 0x46AB, 0x46AB, 0x46AB, 0x46CB, 0x46CC, 0x46CB, 0x4E8B, 0x0EA7 },
    { 0x0505, 0x3EAB, 0x6FCE, 0x5F8D, 0x5F6D, 0x574C, 0x570B, 0x4F0B, 0x46EA, 0x4F2B, 0x6FEF, 0x1EA7 },
    { 0x0527, 0x3E6A, 0x574C, 0x2E48, 0x3668, 0x3688, 0x3688, 0x3688, 0x3668, 0x572B, 0x5F8D, 0x0605 },
    { 0x0526, 0x3EAA, 0x67AE, 0x3648, 0x3E89, 0x3E89, 0x3688, 0x3EA8, 0x3668, 0x574C, 0x1524, 0x0E45 },
    { 0x0526, 0x3E8A, 0x67CE, 0x3668, 0x3689, 0x3E89, 0x3E89, 0x3E89, 0x3EA9, 0x2E27, 0x25C6, 0x0E25 },
    { 0x0526, 0x3EAA, 0x6FEF, 0x3689, 0x36A9, 0x3E89, 0x3689, 0x3689, 0x3EA9, 0x2E07, 0x25A6, 0x0E45 },
    { 0x0526, 0x3EAA, 0x6FEF, 0x3EA9, 0x3E89, 0x3EA9, 0x3689, 0x3689, 0x3EA9, 0x2E27, 0x25C6, 0x0E25 },
    { 0x0526, 0x3EAA, 0x6FEF, 0x46CA, 0x3EA9, 0x3688, 0x3689, 0x3688, 0x3EA9, 0x2E27, 0x25A6, 0x0E45 },
    { 0x0526, 0x3EAA, 0x6FEF, 0x4F4C, 0x3689, 0x3688, 0x3668, 0x3668, 0x3668, 0x2DE7, 0x25A6, 0x0E25 },
    { 0x0526, 0x3EAA, 0x77CF, 0x1D65, 0x2586, 0x1DA6, 0x1D85, 0x25A6, 0x25A6, 0x25A6, 0x2DA5, 0x0644 },
    { 0x05C6, 0x15E8, 0x0DA5, 0x0DC6, 0x15C6, 0x15A6, 0x15C6, 0x15C6, 0x0DC6, 0x0DC7, 0x0DA6, 0x0686 }
  },
  { 
    { 0x7014, 0x5832, 0x5832, 0x5833, 0x5832, 0x5833, 0x5833, 0x5833, 0x5833, 0x5813, 0x5813, 0x5833 },
    { 0x5813, 0xCB7F, 0xCB7F, 0xCB5F, 0xCB9F, 0xCB9F, 0xD39F, 0xD39F, 0xD39F, 0xCB7F, 0xE3BF, 0x60D5 },
    { 0x6014, 0xC31F, 0xAA7D, 0xA21C, 0xA21C, 0x99FC, 0x99DB, 0x99BB, 0x919B, 0xB2BE, 0xCB5F, 0x5834 },
    { 0x5814, 0xBB1F, 0xAA5D, 0x99BB, 0x99BB, 0x99DB, 0x99DC, 0x99DB, 0x919A, 0xC31F, 0x80F8, 0x6034 },
    { 0x5814, 0xBB1F, 0xAA9D, 0x999B, 0x99DB, 0x99DB, 0x99DB, 0x99DB, 0x99BB, 0x99BB, 0x8939, 0x6034 },
    { 0x5814, 0xC31F, 0xB2DE, 0x999B, 0x99DB, 0x99DB, 0x99BB, 0x99DB, 0xA1FC, 0x78D8, 0x8919, 0x6034 },
    { 0x5814, 0xC33F, 0xBAFF, 0x919A, 0x99DB, 0x99BB, 0x99DB, 0x99DB, 0xA1DC, 0x80F8, 0x8939, 0x6034 },
    { 0x5814, 0xC33F, 0xC33F, 0x919B, 0x99BB, 0x99BB, 0x99DB, 0x99BB, 0x99DC, 0x80F8, 0x8139, 0x6035 },
    { 0x5813, 0xC33F, 0xBB3F, 0x999A, 0x99DB, 0x99DB, 0xA1DB, 0xA1FC, 0xA21C, 0x80F8, 0x8939, 0x5834 },
    { 0x5814, 0xC31F, 0xC35F, 0xA1DC, 0x895A, 0x8939, 0x8939, 0x8939, 0x8119, 0x80F8, 0x88F9, 0x6054 },
    { 0x6014, 0xD37F, 0x8939, 0x88F9, 0x8938, 0x8939, 0x8939, 0x8919, 0x8919, 0x8919, 0x915A, 0x6054 },
    { 0x6816, 0x6055, 0x6055, 0x6055, 0x6035, 0x6035, 0x6035, 0x6055, 0x6034, 0x6055, 0x6834, 0x6034 }
  }
};
Block blocks[7] = {//块数据
    {{{{ -1, 0}, {0, 0}, {1, 0}, {2, 0}}, {{0, -1}, {0, 0}, {0, 1}, {0, 2}}, {{0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0}, {0, 0}, {0, 0}, {0, 0}}}, 2, 1},
    {{{{0, -1}, {1, -1}, {0, 0}, {1, 0}}, {{0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0}, {0, 0}, {0, 0}, {0, 0}}}, 1, 2},
    {{{{ -1, -1}, { -1, 0}, {0, 0}, {1, 0}}, {{ -1, 1}, {0, 1}, {0, 0}, {0, -1}}, {{ -1, 0}, {0, 0}, {1, 0}, {1, 1}}, {{1, -1}, {0, -1}, {0, 0}, {0, 1}}}, 4, 3},
    {{{{ -1, 0}, {0, 0}, {0, 1}, {1, 1}}, {{0, -1}, {0, 0}, { -1, 0}, { -1, 1}}, {{0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0}, {0, 0}, {0, 0}, {0, 0}}}, 2, 4},
    {{{{ -1, 0}, {0, 0}, {1, 0}, {1, -1}}, {{ -1, -1}, {0, -1}, {0, 0}, {0, 1}}, {{ -1, 1}, { -1, 0}, {0, 0}, {1, 0}}, {{0, -1}, {0, 0}, {0, 1}, {1, 1}}}, 4, 5},
    {{{{ -1, 1}, {0, 1}, {0, 0}, {1, 0}}, {{0, -1}, {0, 0}, {1, 0}, {1, 1}}, {{0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0}, {0, 0}, {0, 0}, {0, 0}}}, 2, 6},
    {{{{ -1, 0}, {0, 0}, {1, 0}, {0, -1}}, {{0, -1}, {0, 0}, {0, 1}, { -1, 0}}, {{ -1, 0}, {0, 0}, {1, 0}, {0, 1}}, {{0, -1}, {0, 0}, {0, 1}, {1, 0}}}, 4, 7}
};
// 构造函数
TetrisBlock::TetrisBlock(){
    memset(backBuffer, 0, sizeof(backBuffer));
    memset(newblock, 0, sizeof(newblock));
    memset(screen,0,sizeof(screen));
    started = false;//游戏开始标志位
    gameover = false;//游戏结束标志位
    score = 0;//分数  
    unsigned int last_score=0xFFFF;
    int last_block_num_rotate=0xFFFF;
    int last_block_color=0xFFFF;
    
}
void TetrisBlock::gameInit(){
    memset(backBuffer, 0, sizeof(backBuffer));
    memset(newblock, 0, sizeof(newblock));
    memset(screen,0,sizeof(screen));
    started = false;//游戏开始标志位
    gameover = false;//游戏结束标志位
    score = 0;//分数  
    unsigned int last_score=0xFFFF;
    int last_block_num_rotate=0xFFFF;
    int last_block_color=0xFFFF;
    next_block = blocks[random(7)];//下一个块
    next_rot = random()%next_block.numRotate;//下一个块方向
    pre_pos.x = 4;
    pre_pos.y = 1;
    pre_block=next_block;
    pre_rot=next_rot;
    next_block = blocks[random(7)];//下一个块
    next_rot = random()%next_block.numRotate;//下一个块方向
    TimeElsp = 0;
    for (int i = 0; i < 4; ++i) screen[pre_pos.x + pre_block.square[pre_rot][i].x][pre_pos.y + pre_block.square[pre_rot][i].y] = pre_block.color;
    Draw();
}
void TetrisBlock::Draw(){
    if ((last_score!=score)||(next_block.numRotate!=last_block_num_rotate)||(next_block.color!=last_block_color)) { 
        //绘制下一个俄罗斯方块
        memset(newblock,0,sizeof(newblock));
        int putX=24,putY=12; 
        int x1 ,y1;
        for (int z=0;z<4;z++)
            for (int k = 0; k < Length; ++k) for (int l = 0; l < Length; ++l)
                {
                    x1 = putX + (next_block.square[next_rot][z].y * Length-k);
                    y1 = putY + (next_block.square[next_rot][z].x * Length+l);
                    newblock[x1][y1] = BlockImage[next_block.color][k][l];      
                }
                  
        last_block_num_rotate = next_block.numRotate;
        last_block_color = next_block.color;
        tft.pushImage(NextBlockArePosX1, NextBlockArePosY1, 48, 48,(uint16_t*)newblock);//绘制下一个块
        // Convert backBuffer to 100*240
        // for (int i = 0 ; i < 240; ++i) for (int j = 0; j < 100; ++j) {
        //     backBuffer[(i*100+j)/120][(i*100+j)%120]= backBuffer[i][j];}
        
        //Draw buffer
        // tft.fillImage(backBuffer, 0, 0, 100, 240);
        
        // Draw score to the screen
    
        // 绘制分数
        tft.fillRect(SocoreArePosX1, SocoreArePosY1, 64, 16, TFT_WHITE);
        tft.setCursor(SocoreArePosX1, SocoreArePosY1);
        tft.setTextColor(TFT_BLACK);  
        tft.setTextSize(2);
        char tmp[20]; 
        sprintf(tmp, "%04d", score);
        tft.println(tmp);
        last_score=score;
    }
    
    // 将当前块绘制到游戏区  
    for (int i = 0; i < Width; ++i) for (int j = 0; j < Height; ++j)
        for (int k = 0; k < Length; ++k) for (int l = 0; l < Length; ++l)
            backBuffer[j * Length + l][i * Length + k] = BlockImage[screen[i][j]][k][l];
    tft.pushImage(GameAreStartPosX1, GameAreStartPosY1, 120, 240,(uint16_t*)backBuffer);    
}
// 旋转方块
void TetrisBlock::delectLine() {
    int DeleteCount=0;
    for (int j = 0; j < Height; ++j) {
        bool Delete = true;
        for (int i = 0; i < Width; ++i) if (screen[i][j] == 0) Delete = false; 
        if (Delete) { 
        for (int k = j; k >= 1; --k) for (int i = 0; i < Width; ++i) screen[i][k] = screen[i][k - 1];
            DeleteCount++; 
        }
    }
    if (DeleteCount!=0) {score+=DeleteCount*DeleteCount;}
}

// 移动方块
void TetrisBlock::gameOver() {
    for (int i = 0; i < Width; ++i) for (int j = 0; j < Height; ++j) if (screen[i][j] != 0) screen[i][j] = 4;
    gameover = true;
}
void TetrisBlock::reviseScreen(Point next_pos, int next_rot) {
    if (!started) return;
    Point next_squares[4];
    for (int i = 0; i < 4; ++i) screen[pre_pos.x + pre_block.square[pre_rot][i].x][pre_pos.y + pre_block.square[pre_rot][i].y] = 0;
    if (getSquares(pre_block, next_pos, next_rot, next_squares)) {
        Serial.println("有效");
        for (int i = 0; i < 4; ++i) screen[next_squares[i].x][next_squares[i].y] = pre_block.color;
        pre_pos = next_pos;
        pre_rot = next_rot;
    }
    else {
        Serial.println("无效"); 
        for (int i = 0; i < 4; ++i) screen[pre_pos.x + pre_block.square[pre_rot][i].x][pre_pos.y + pre_block.square[pre_rot][i].y] = pre_block.color;
        if (next_pos.y == pre_pos.y + 1) {
            delectLine();
            Serial.println("1"); 
            putStartPos();
            Serial.println("2"); 
            if (!getSquares(pre_block, pre_pos, pre_rot, next_squares)) {
                for (int i = 0; i < 4; ++i) screen[pre_pos.x + pre_block.square[pre_rot][i].x][pre_pos.y + pre_block.square[pre_rot][i].y] = pre_block.color;
                gameOver();
            }
        }
    }
    Draw();
}
void TetrisBlock::putStartPos() {
    pre_pos.x = 4;
    pre_pos.y = 1;

    pre_block=next_block;
    pre_rot=next_rot;
    int c=random(7);
    next_block = blocks[c];
    next_rot = random(next_block.numRotate);  
}

bool TetrisBlock::getSquares(Block block, Point pos, int rot, Point* squares){
    bool overlap = false;
    Serial.println("posx");
    Serial.println(pos.x);
    Serial.println("posy");
    Serial.println(pos.y);
    for (int i = 0; i < 4; ++i) {
        Point p;
        p.x = pos.x + block.square[rot][i].x;
        p.y = pos.y + block.square[rot][i].y;
        overlap |= p.x < 0 || p.x >= Width || p.y < 0 || p.y >= Height || screen[p.x][p.y] != 0;
        squares[i] = p;
        
    }
    return !overlap;
}
unsigned long TetrisBlock::score2Level(){
    if (score>=200) {return 50;}
    return (2000-(score/10)*100);
}

void TetrisBlock::getNextPosRot(Point* pnext_pos, int* pnext_rot, bool received, boolean* Button_A, boolean* Button_LEFT, boolean* Button_RIGHT, boolean* Button_DOWN, boolean* Button_UP) {
    // bool received = KeyPadLoop();
    if (*Button_A) started = true;
    if (!started) return;
    pnext_pos->x = pre_pos.x;
    pnext_pos->y = pre_pos.y;
    // if ((fall_cnt = (fall_cnt + 1) % 10) == 0) pnext_pos->Y += 1;
    if ((millis()-TimeElsp)>score2Level()) {pnext_pos->y += 1;TimeElsp=millis();}
    else if (received) {
        if (*Button_LEFT) {
            *Button_LEFT = false;
            pnext_pos->x -= 1;
        }
        else if (*Button_RIGHT) {
            *Button_RIGHT = false;
            pnext_pos->x += 1;
        }
        else if (*Button_DOWN) {
            *Button_DOWN = false;
            pnext_pos->y += 1;
        }
        else if (*Button_UP) {
            *Button_A = false;
            *pnext_rot = (*pnext_rot + pre_block.numRotate - 1)%pre_block.numRotate; 
        }
    }
}
TetrisBlock::~TetrisBlock() {

}